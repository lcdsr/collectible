"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FORMAT_ERROR_BODY_MAX_LENGTH = 1000;
exports.CONTENT_TYPE_JSON = 'application/json';
exports.ERROR_UNKNOWN_CONTENT_TYPE = 'UNKNOWN_CONTENT_TYPE';
exports.ERROR_UNKNOWN_RESPONSE_FORMAT = 'UNKNOWN_RESPONSE_FORMAT';
let CAS;
let CERTS;
let KEYS;
function getGlobalProxy() {
    const envvars = ['IONIC_HTTP_PROXY', 'HTTPS_PROXY', 'HTTP_PROXY', 'PROXY', 'https_proxy', 'http_proxy', 'proxy'];
    for (const envvar of envvars) {
        if (process.env[envvar]) {
            return [process.env[envvar], envvar];
        }
    }
    return [undefined, undefined];
}
exports.getGlobalProxy = getGlobalProxy;
async function createRawRequest(method, url) {
    const superagent = await Promise.resolve().then(() => require('superagent'));
    try {
        const superagentProxy = await Promise.resolve().then(() => require('superagent-proxy'));
        superagentProxy(superagent);
    }
    catch (e) {
        if (e.code !== 'MODULE_NOT_FOUND') {
            throw e;
        }
    }
    return { req: superagent(method, url) };
}
exports.createRawRequest = createRawRequest;
async function createRequest(method, url) {
    const [proxy] = getGlobalProxy();
    const { req } = await createRawRequest(method, url);
    if (proxy && req.proxy) {
        req.proxy(proxy);
    }
    return { req };
}
exports.createRequest = createRequest;
async function download(url, ws, opts) {
    const { req } = await createRequest('get', url);
    const progressFn = opts ? opts.progress : undefined;
    return new Promise((resolve, reject) => {
        req
            .on('response', (res) => {
            if (res.statusCode !== 200) {
                reject(new Error(`Encountered bad status code (${res.statusCode}) for ${url}\n` +
                    `This could mean the server is experiencing difficulties right now--please try again later.`));
            }
            if (progressFn) {
                let loaded = 0;
                const total = Number(res.headers['content-length']);
                res.on('data', (chunk) => {
                    loaded += chunk.length;
                    progressFn(loaded, total);
                });
            }
        })
            .on('error', (err) => {
            if (err.code === 'ECONNABORTED') {
                reject(new Error(`Timeout of ${err.timeout}ms reached for ${url}`));
            }
            else {
                reject(err);
            }
        })
            .on('end', resolve);
        req.pipe(ws);
    });
}
exports.download = download;
